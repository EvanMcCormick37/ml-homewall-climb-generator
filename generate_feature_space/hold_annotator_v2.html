<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Climbing Hold Annotator v2</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #1a1a2e;
            color: white;
            overflow: hidden;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }
        
        .header {
            padding: 10px 20px;
            background: #16213e;
            border-bottom: 1px solid #333;
        }
        
        h1 {
            font-size: 1.3em;
            color: #00ff88;
            margin-bottom: 8px;
        }
        
        .toolbar {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            align-items: center;
        }
        
        .toolbar-group {
            display: flex;
            gap: 5px;
            align-items: center;
            padding: 0 10px;
            border-right: 1px solid #444;
        }
        
        .toolbar-group:last-child {
            border-right: none;
        }
        
        .toolbar-group label {
            font-size: 12px;
            color: #888;
        }
        
        button {
            padding: 6px 12px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s;
        }
        
        button.mode-btn {
            background: #333;
            color: white;
        }
        
        button.mode-btn.active {
            background: #00ff88;
            color: black;
        }
        
        button.action-btn {
            background: #4a90d9;
            color: white;
        }
        
        button.action-btn:hover {
            background: #3a7bc8;
        }
        
        button.danger {
            background: #d94a4a;
        }
        
        .status {
            background: #333;
            padding: 5px 10px;
            border-radius: 4px;
            font-family: monospace;
            font-size: 11px;
        }
        
        input[type="range"] {
            width: 80px;
            cursor: pointer;
        }
        
        input[type="number"] {
            width: 60px;
            padding: 3px 5px;
            border: 1px solid #444;
            border-radius: 3px;
            background: #222;
            color: white;
            font-size: 11px;
        }
        
        .canvas-wrapper {
            flex: 1;
            overflow: hidden;
            position: relative;
            background: #0a0a15;
        }
        
        .canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            cursor: grab;
        }
        
        .canvas-container.dragging {
            cursor: grabbing;
        }
        
        canvas {
            display: block;
        }
        
        input[type="file"] {
            display: none;
        }
        
        .file-label {
            padding: 6px 12px;
            background: #4a90d9;
            color: white;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }
        
        .file-label:hover {
            background: #3a7bc8;
        }
        
        .help-panel {
            position: fixed;
            bottom: 10px;
            right: 10px;
            background: rgba(0,0,0,0.85);
            padding: 12px;
            border-radius: 8px;
            font-size: 11px;
            max-width: 280px;
            border: 1px solid #333;
        }
        
        .help-panel h4 {
            color: #00ff88;
            margin-bottom: 8px;
        }
        
        .help-panel ul {
            padding-left: 15px;
            line-height: 1.6;
        }
        
        .help-panel kbd {
            background: #333;
            padding: 1px 5px;
            border-radius: 3px;
            font-family: monospace;
        }
        
        .alignment-panel {
            position: fixed;
            top: 80px;
            right: 10px;
            background: rgba(0,0,0,0.9);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #444;
            min-width: 200px;
        }
        
        .alignment-panel h4 {
            color: #00ff88;
            margin-bottom: 12px;
            font-size: 13px;
        }
        
        .alignment-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 10px;
        }
        
        .alignment-row label {
            font-size: 12px;
            color: #aaa;
        }
        
        .alignment-row input[type="range"] {
            width: 100px;
        }
        
        .alignment-row input[type="number"] {
            width: 55px;
        }
        
        .alignment-panel button {
            width: 100%;
            margin-top: 5px;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>üßó Climbing Hold Annotator v2</h1>
        
        <div class="toolbar">
            <div class="toolbar-group">
                <label class="file-label">
                    üì∑ Image
                    <input type="file" id="imageInput" accept="image/*">
                </label>
                <label class="file-label">
                    üìÅ JSON
                    <input type="file" id="jsonInput" accept=".json">
                </label>
            </div>
            
            <div class="toolbar-group">
                <button class="mode-btn active" id="viewBtn">üëÅÔ∏è View</button>
                <button class="mode-btn" id="addBtn">‚ûï Add</button>
                <button class="mode-btn" id="removeBtn">‚ûñ Remove</button>
                <button class="mode-btn" id="panBtn">‚úã Pan</button>
            </div>
            
            <div class="toolbar-group">
                <label>Zoom:</label>
                <button class="action-btn" id="zoomOutBtn">‚àí</button>
                <input type="range" id="zoomSlider" min="10" max="200" value="100">
                <button class="action-btn" id="zoomInBtn">+</button>
                <button class="action-btn" id="fitBtn">Fit</button>
            </div>
            
            <div class="toolbar-group">
                <button class="action-btn" id="exportBtn">üíæ Export</button>
                <button class="action-btn danger" id="clearBtn">üóëÔ∏è Clear</button>
            </div>
            
            <span class="status" id="status">Load an image to start</span>
        </div>
    </div>
    
    <div class="canvas-wrapper" id="canvasWrapper">
        <div class="canvas-container" id="canvasContainer">
            <canvas id="canvas"></canvas>
        </div>
    </div>
    
    <!-- Alignment Controls Panel -->
    <div class="alignment-panel" id="alignmentPanel" style="display: none;">
        <h4>üéØ Hold Alignment</h4>
        <p style="font-size: 11px; color: #888; margin-bottom: 12px;">
            Adjust to align JSON holds with image
        </p>
        
        <div class="alignment-row">
            <label>Scale:</label>
            <input type="range" id="holdScale" min="0.1" max="3" step="0.01" value="1">
            <input type="number" id="holdScaleNum" min="0.1" max="3" step="0.01" value="1">
        </div>
        
        <div class="alignment-row">
            <label>Offset X:</label>
            <input type="range" id="holdOffsetX" min="-500" max="500" value="0">
            <input type="number" id="holdOffsetXNum" value="0">
        </div>
        
        <div class="alignment-row">
            <label>Offset Y:</label>
            <input type="range" id="holdOffsetY" min="-500" max="500" value="0">
            <input type="number" id="holdOffsetYNum" value="0">
        </div>
        
        <button class="action-btn" id="resetAlignBtn">Reset Alignment</button>
        <button class="action-btn" id="applyAlignBtn" style="background: #00aa66;">Apply to Holds</button>
    </div>
    
    <div class="help-panel">
        <h4>Controls</h4>
        <ul>
            <li><kbd>Scroll</kbd> to zoom</li>
            <li><kbd>Drag</kbd> to pan (in Pan mode)</li>
            <li><kbd>Click</kbd> to add/remove holds</li>
            <li><kbd>F</kbd> to fit image to window</li>
            <li><kbd>1-4</kbd> to switch modes</li>
        </ul>
    </div>
    
    <script>
        // ============ State ============
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const wrapper = document.getElementById('canvasWrapper');
        const container = document.getElementById('canvasContainer');
        const status = document.getElementById('status');
        const alignmentPanel = document.getElementById('alignmentPanel');
        
        let image = null;
        let imageWidth = 0;
        let imageHeight = 0;
        let holds = [];
        let mode = 'view'; // 'view', 'add', 'remove', 'pan'
        let nextId = 0;
        
        // View transform
        let viewZoom = 1;
        let viewX = 0;
        let viewY = 0;
        
        // Hold alignment transform (for matching JSON to different-sized images)
        let holdScale = 1;
        let holdOffsetX = 0;
        let holdOffsetY = 0;
        
        // Drag state
        let isDragging = false;
        let dragStartX = 0;
        let dragStartY = 0;
        let dragStartViewX = 0;
        let dragStartViewY = 0;
        
        // ============ Mode Controls ============
        document.getElementById('viewBtn').onclick = () => setMode('view');
        document.getElementById('addBtn').onclick = () => setMode('add');
        document.getElementById('removeBtn').onclick = () => setMode('remove');
        document.getElementById('panBtn').onclick = () => setMode('pan');
        
        function setMode(newMode) {
            mode = newMode;
            document.querySelectorAll('.mode-btn').forEach(btn => btn.classList.remove('active'));
            document.getElementById(newMode + 'Btn').classList.add('active');
            
            // Update cursor
            if (mode === 'pan') {
                canvas.style.cursor = 'grab';
            } else if (mode === 'add') {
                canvas.style.cursor = 'crosshair';
            } else if (mode === 'remove') {
                canvas.style.cursor = 'pointer';
            } else {
                canvas.style.cursor = 'default';
            }
            
            updateStatus();
        }
        
        function updateStatus() {
            const modeNames = {view: 'View', add: 'Add', remove: 'Remove', pan: 'Pan'};
            status.textContent = `${modeNames[mode]} | Holds: ${holds.length} | Zoom: ${Math.round(viewZoom * 100)}%`;
        }
        
        // ============ Zoom Controls ============
        const zoomSlider = document.getElementById('zoomSlider');
        
        document.getElementById('zoomInBtn').onclick = () => {
            viewZoom = Math.min(3, viewZoom * 1.2);
            zoomSlider.value = viewZoom * 100;
            updateTransform();
        };
        
        document.getElementById('zoomOutBtn').onclick = () => {
            viewZoom = Math.max(0.1, viewZoom / 1.2);
            zoomSlider.value = viewZoom * 100;
            updateTransform();
        };
        
        zoomSlider.oninput = () => {
            viewZoom = zoomSlider.value / 100;
            updateTransform();
        };
        
        document.getElementById('fitBtn').onclick = fitToWindow;
        
        function fitToWindow() {
            if (!image) return;
            
            const wrapperRect = wrapper.getBoundingClientRect();
            const scaleX = wrapperRect.width / imageWidth;
            const scaleY = wrapperRect.height / imageHeight;
            viewZoom = Math.min(scaleX, scaleY) * 0.95;
            
            // Center the image
            viewX = (wrapperRect.width - imageWidth * viewZoom) / 2;
            viewY = (wrapperRect.height - imageHeight * viewZoom) / 2;
            
            zoomSlider.value = viewZoom * 100;
            updateTransform();
        }
        
        function updateTransform() {
            container.style.transform = `translate(${viewX}px, ${viewY}px)`;
            canvas.style.width = (imageWidth * viewZoom) + 'px';
            canvas.style.height = (imageHeight * viewZoom) + 'px';
            updateStatus();
        }
        
        // ============ Alignment Controls ============
        const holdScaleSlider = document.getElementById('holdScale');
        const holdScaleNum = document.getElementById('holdScaleNum');
        const holdOffsetXSlider = document.getElementById('holdOffsetX');
        const holdOffsetXNum = document.getElementById('holdOffsetXNum');
        const holdOffsetYSlider = document.getElementById('holdOffsetY');
        const holdOffsetYNum = document.getElementById('holdOffsetYNum');
        
        function syncAlignmentControls() {
            holdScaleSlider.value = holdScale;
            holdScaleNum.value = holdScale;
            holdOffsetXSlider.value = holdOffsetX;
            holdOffsetXNum.value = holdOffsetX;
            holdOffsetYSlider.value = holdOffsetY;
            holdOffsetYNum.value = holdOffsetY;
        }
        
        holdScaleSlider.oninput = () => {
            holdScale = parseFloat(holdScaleSlider.value);
            holdScaleNum.value = holdScale;
            draw();
        };
        holdScaleNum.onchange = () => {
            holdScale = parseFloat(holdScaleNum.value);
            holdScaleSlider.value = holdScale;
            draw();
        };
        
        holdOffsetXSlider.oninput = () => {
            holdOffsetX = parseInt(holdOffsetXSlider.value);
            holdOffsetXNum.value = holdOffsetX;
            draw();
        };
        holdOffsetXNum.onchange = () => {
            holdOffsetX = parseInt(holdOffsetXNum.value);
            holdOffsetXSlider.value = holdOffsetX;
            draw();
        };
        
        holdOffsetYSlider.oninput = () => {
            holdOffsetY = parseInt(holdOffsetYSlider.value);
            holdOffsetYNum.value = holdOffsetY;
            draw();
        };
        holdOffsetYNum.onchange = () => {
            holdOffsetY = parseInt(holdOffsetYNum.value);
            holdOffsetYSlider.value = holdOffsetY;
            draw();
        };
        
        document.getElementById('resetAlignBtn').onclick = () => {
            holdScale = 1;
            holdOffsetX = 0;
            holdOffsetY = 0;
            syncAlignmentControls();
            draw();
        };
        
        document.getElementById('applyAlignBtn').onclick = () => {
            // Permanently apply alignment to hold coordinates
            holds.forEach(hold => {
                hold.pixel_x = Math.round(hold.pixel_x * holdScale + holdOffsetX);
                hold.pixel_y = Math.round(hold.pixel_y * holdScale + holdOffsetY);
                hold.norm_x = hold.pixel_x / imageWidth;
                hold.norm_y = 1 - (hold.pixel_y / imageHeight);
            });
            
            // Reset alignment
            holdScale = 1;
            holdOffsetX = 0;
            holdOffsetY = 0;
            syncAlignmentControls();
            draw();
            
            alert(`Applied alignment to ${holds.length} holds. Coordinates have been updated.`);
        };
        
        // ============ File Loading ============
        document.getElementById('imageInput').onchange = (e) => {
            const file = e.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = (event) => {
                image = new Image();
                image.onload = () => {
                    imageWidth = image.width;
                    imageHeight = image.height;
                    
                    canvas.width = imageWidth;
                    canvas.height = imageHeight;
                    
                    // Fit to window on load
                    fitToWindow();
                    draw();
                    updateStatus();
                    
                    // Show alignment panel if we have holds
                    if (holds.length > 0) {
                        alignmentPanel.style.display = 'block';
                    }
                };
                image.src = event.target.result;
            };
            reader.readAsDataURL(file);
        };
        
        document.getElementById('jsonInput').onchange = (e) => {
            const file = e.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = (event) => {
                try {
                    const data = JSON.parse(event.target.result);
                    holds = data.holds || [];
                    nextId = Math.max(...holds.map(h => h.hold_id), -1) + 1;
                    
                    // Show alignment panel
                    if (image) {
                        alignmentPanel.style.display = 'block';
                    }
                    
                    draw();
                    updateStatus();
                } catch (err) {
                    alert('Error loading JSON: ' + err.message);
                }
            };
            reader.readAsText(file);
        };
        
        // ============ Mouse/Touch Handling ============
        canvas.onmousedown = (e) => {
            if (mode === 'pan') {
                isDragging = true;
                dragStartX = e.clientX;
                dragStartY = e.clientY;
                dragStartViewX = viewX;
                dragStartViewY = viewY;
                container.classList.add('dragging');
                canvas.style.cursor = 'grabbing';
            }
        };
        
        window.onmousemove = (e) => {
            if (isDragging && mode === 'pan') {
                viewX = dragStartViewX + (e.clientX - dragStartX);
                viewY = dragStartViewY + (e.clientY - dragStartY);
                updateTransform();
            }
        };
        
        window.onmouseup = () => {
            if (isDragging) {
                isDragging = false;
                container.classList.remove('dragging');
                if (mode === 'pan') {
                    canvas.style.cursor = 'grab';
                }
            }
        };
        
        canvas.onclick = (e) => {
            if (!image || mode === 'pan' || isDragging) return;
            
            // Get click position in image coordinates
            const rect = canvas.getBoundingClientRect();
            const scaleX = imageWidth / rect.width;
            const scaleY = imageHeight / rect.height;
            const x = Math.round((e.clientX - rect.left) * scaleX);
            const y = Math.round((e.clientY - rect.top) * scaleY);
            
            if (mode === 'add') {
                addHold(x, y);
            } else if (mode === 'remove') {
                removeHoldAt(x, y);
            } else if (mode === 'view') {
                const hold = findHoldAt(x, y);
                if (hold) {
                    alert(`Hold #${hold.hold_id}\nPixel: (${hold.pixel_x}, ${hold.pixel_y})\nNormalized: (${hold.norm_x.toFixed(3)}, ${hold.norm_y.toFixed(3)})\nArea: ${hold.area} px¬≤`);
                }
            }
        };
        
        // Mouse wheel zoom
        wrapper.onwheel = (e) => {
            e.preventDefault();
            
            const delta = e.deltaY > 0 ? 0.9 : 1.1;
            const newZoom = Math.max(0.1, Math.min(3, viewZoom * delta));
            
            // Zoom toward cursor
            const rect = wrapper.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            
            const beforeX = (mouseX - viewX) / viewZoom;
            const beforeY = (mouseY - viewY) / viewZoom;
            
            viewZoom = newZoom;
            
            viewX = mouseX - beforeX * viewZoom;
            viewY = mouseY - beforeY * viewZoom;
            
            zoomSlider.value = viewZoom * 100;
            updateTransform();
        };
        
        // ============ Keyboard Shortcuts ============
        document.onkeydown = (e) => {
            if (e.target.tagName === 'INPUT') return;
            
            switch(e.key) {
                case '1': setMode('view'); break;
                case '2': setMode('add'); break;
                case '3': setMode('remove'); break;
                case '4': setMode('pan'); break;
                case 'f': case 'F': fitToWindow(); break;
            }
        };
        
        // ============ Hold Operations ============
        function addHold(x, y) {
            // Get color at position
            let color = [128, 128, 128];
            try {
                const data = ctx.getImageData(x, y, 1, 1).data;
                color = [data[0], data[1], data[2]];
            } catch (err) {}
            
            const hold = {
                hold_id: nextId++,
                pixel_x: x,
                pixel_y: y,
                norm_x: x / imageWidth,
                norm_y: 1 - (y / imageHeight),
                area: 500,
                color_rgb: color,
                confidence: 1.0,
                manual: true
            };
            
            holds.push(hold);
            draw();
            updateStatus();
        }
        
        function removeHoldAt(x, y) {
            // Account for alignment transform when finding holds
            const hold = findHoldAt(x, y);
            if (hold) {
                holds = holds.filter(h => h !== hold);
                draw();
                updateStatus();
            }
        }
        
        function findHoldAt(x, y, radius = 40) {
            let nearest = null;
            let minDist = Infinity;
            
            for (const hold of holds) {
                // Apply alignment transform to hold position
                const hx = hold.pixel_x * holdScale + holdOffsetX;
                const hy = hold.pixel_y * holdScale + holdOffsetY;
                
                const dist = Math.sqrt((hx - x) ** 2 + (hy - y) ** 2);
                if (dist < minDist && dist < radius) {
                    minDist = dist;
                    nearest = hold;
                }
            }
            return nearest;
        }
        
        // ============ Drawing ============
        function draw() {
            if (!image) {
                ctx.fillStyle = '#1a1a2e';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = '#666';
                ctx.font = '24px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('Load an image to begin', canvas.width/2, canvas.height/2);
                return;
            }
            
            // Draw image
            ctx.drawImage(image, 0, 0);
            
            // Draw holds with alignment transform
            for (const hold of holds) {
                const x = hold.pixel_x * holdScale + holdOffsetX;
                const y = hold.pixel_y * holdScale + holdOffsetY;
                const radius = Math.max(12, Math.sqrt((hold.area || 500) / Math.PI) * holdScale);
                
                // Circle
                ctx.beginPath();
                ctx.arc(x, y, radius, 0, 2 * Math.PI);
                ctx.strokeStyle = hold.manual ? '#00aaff' : '#00ff88';
                ctx.lineWidth = 3;
                ctx.stroke();
                
                // ID label background
                ctx.fillStyle = 'rgba(0, 0, 0, 0.85)';
                const text = hold.hold_id.toString();
                ctx.font = 'bold 14px sans-serif';
                const textWidth = ctx.measureText(text).width;
                ctx.fillRect(x - textWidth/2 - 4, y - 9, textWidth + 8, 18);
                
                // ID text
                ctx.fillStyle = 'white';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(text, x, y);
            }
        }
        
        // ============ Export ============
        document.getElementById('exportBtn').onclick = () => {
            // Sort and renumber
            holds.sort((a, b) => b.norm_y - a.norm_y || a.norm_x - b.norm_x);
            holds.forEach((h, i) => h.hold_id = i);
            
            const data = {
                metadata: {
                    wall_name: "Home Spray Wall",
                    num_holds: holds.length,
                    image_dimensions: [imageWidth, imageHeight],
                    exported: new Date().toISOString()
                },
                holds: holds
            };
            
            const blob = new Blob([JSON.stringify(data, null, 2)], {type: 'application/json'});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'holds_annotated.json';
            a.click();
            URL.revokeObjectURL(url);
            
            draw();
            updateStatus();
        };
        
        document.getElementById('clearBtn').onclick = () => {
            if (confirm('Remove all holds?')) {
                holds = [];
                nextId = 0;
                draw();
                updateStatus();
            }
        };
        
        // ============ Initial State ============
        updateStatus();
    </script>
</body>
</html>
